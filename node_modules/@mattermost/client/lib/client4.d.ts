import type { ClusterInfo, AnalyticsRow, SchemaMigration, LogFilterQuery } from '@mattermost/types/admin';
import type { AppBinding, AppCallRequest, AppCallResponse } from '@mattermost/types/apps';
import type { Audit } from '@mattermost/types/audits';
import type { UserAutocomplete, AutocompleteSuggestion } from '@mattermost/types/autocomplete';
import type { Bot, BotPatch } from '@mattermost/types/bots';
import type { ChannelBookmark, ChannelBookmarkCreate, ChannelBookmarkPatch } from '@mattermost/types/channel_bookmarks';
import type { ChannelCategory, OrderedChannelCategories } from '@mattermost/types/channel_categories';
import type { Channel, ChannelMemberCountsByGroup, ChannelMembership, ChannelModeration, ChannelModerationPatch, ChannelStats, ChannelsWithTotalCount, ChannelUnread, ChannelViewResponse, ChannelWithTeamData, ChannelSearchOpts, ServerChannel } from '@mattermost/types/channels';
import type { Options, StatusOK, ClientResponse, FetchPaginatedThreadOptions } from '@mattermost/types/client4';
import { LogLevel } from '@mattermost/types/client4';
import type { Address, Product, CloudCustomer, CloudCustomerPatch, Invoice, Limits, NotifyAdminRequest, Subscription, ValidBusinessEmail, NewsletterRequestBody, Installation } from '@mattermost/types/cloud';
import type { Compliance } from '@mattermost/types/compliance';
import type { ClientConfig, ClientLicense, DataRetentionPolicy, License, AdminConfig, EnvironmentConfig, RequestLicenseBody, AllowedIPRanges, AllowedIPRange, FetchIPResponse } from '@mattermost/types/config';
import type { DataRetentionCustomPolicies, CreateDataRetentionCustomPolicy, PatchDataRetentionCustomPolicy, GetDataRetentionCustomPoliciesRequest } from '@mattermost/types/data_retention';
import type { Draft } from '@mattermost/types/drafts';
import type { CustomEmoji } from '@mattermost/types/emojis';
import type { ServerError } from '@mattermost/types/errors';
import type { FileInfo, FileUploadResponse, FileSearchResults } from '@mattermost/types/files';
import type { SystemSetting } from '@mattermost/types/general';
import type { Group, GroupPatch, GroupSyncable, MixedUnlinkedGroup, SyncablePatch, UsersWithGroupsAndCount, GroupsWithCount, GroupCreateWithUserIds, GroupSearchParams, CustomGroupPatch, GetGroupsParams, GetGroupsForUserParams, GroupStats } from '@mattermost/types/groups';
import type { PostActionResponse } from '@mattermost/types/integration_actions';
import type { Command, CommandArgs, CommandResponse, DialogSubmission, IncomingWebhook, IncomingWebhooksWithCount, OAuthApp, OutgoingOAuthConnection, OutgoingWebhook, SubmitDialogResponse } from '@mattermost/types/integrations';
import type { Job, JobTypeBase } from '@mattermost/types/jobs';
import type { ServerLimits } from '@mattermost/types/limits';
import type { MarketplaceApp, MarketplacePlugin } from '@mattermost/types/marketplace';
import type { MfaSecret } from '@mattermost/types/mfa';
import type { ClientPluginManifest, PluginManifest, PluginsResponse, PluginStatus } from '@mattermost/types/plugins';
import type { Post, PostList, PostSearchResults, PostsUsageResponse, TeamsUsageResponse, PaginatedPostList, FilesUsageResponse, PostAcknowledgement, PostInfo } from '@mattermost/types/posts';
import type { PreferenceType } from '@mattermost/types/preferences';
import type { ProductNotices } from '@mattermost/types/product_notices';
import type { Reaction } from '@mattermost/types/reactions';
import type { UserReport, UserReportFilter, UserReportOptions } from '@mattermost/types/reports';
import type { Role } from '@mattermost/types/roles';
import type { SamlCertificateStatus, SamlMetadataResponse } from '@mattermost/types/saml';
import type { Scheme } from '@mattermost/types/schemes';
import type { Session } from '@mattermost/types/sessions';
import type { CompleteOnboardingRequest } from '@mattermost/types/setup';
import type { GetTeamMembersOpts, Team, TeamInviteWithError, TeamMembership, TeamMemberWithError, TeamStats, TeamsWithCount, TeamUnread, TeamSearchOpts, PagedTeamSearchOpts, NotPagedTeamSearchOpts } from '@mattermost/types/teams';
import type { TermsOfService } from '@mattermost/types/terms_of_service';
import type { UserThreadList, UserThread, UserThreadWithPost } from '@mattermost/types/threads';
import type { AuthChangeResponse, UserAccessToken, UserProfile, UsersStats, UserStatus, GetFilteredUsersStatsOpts, UserCustomStatus } from '@mattermost/types/users';
import type { DeepPartial, RelationOneToOne } from '@mattermost/types/utilities';
import type { TelemetryHandler } from './telemetry';
export declare const HEADER_X_CLUSTER_ID = "X-Cluster-Id";
export declare const HEADER_X_VERSION_ID = "X-Version-Id";
export declare const DEFAULT_LIMIT_BEFORE = 30;
export declare const DEFAULT_LIMIT_AFTER = 30;
export default class Client4 {
    logToConsole: boolean;
    serverVersion: string;
    clusterId: string;
    token: string;
    csrf: string;
    url: string;
    urlVersion: string;
    userAgent: string | null;
    enableLogging: boolean;
    defaultHeaders: {
        [x: string]: string;
    };
    userId: string;
    diagnosticId: string;
    includeCookies: boolean;
    setAuthHeader: boolean;
    translations: {
        connectionError: string;
        unknownError: string;
    };
    userRoles: string;
    telemetryHandler?: TelemetryHandler;
    getUrl(): string;
    getAbsoluteUrl(baseUrl: string): string;
    setUrl(url: string): void;
    setUserAgent(userAgent: string): void;
    getToken(): string;
    setToken(token: string): void;
    setCSRF(csrfToken: string): void;
    setAcceptLanguage(locale: string): void;
    setHeader(header: string, value: string): void;
    removeHeader(header: string): void;
    setEnableLogging(enable: boolean): void;
    setIncludeCookies(include: boolean): void;
    setUserId(userId: string): void;
    setUserRoles(roles: string): void;
    setDiagnosticId(diagnosticId: string): void;
    setTelemetryHandler(telemetryHandler?: TelemetryHandler): void;
    getServerVersion(): string;
    getUrlVersion(): string;
    getBaseRoute(): string;
    getAppsProxyRoute(): string;
    getUsersRoute(): string;
    getUserRoute(userId: string): string;
    getTeamsRoute(): string;
    getTeamRoute(teamId: string): string;
    getTeamSchemeRoute(teamId: string): string;
    getTeamNameRoute(teamName: string): string;
    getTeamMembersRoute(teamId: string): string;
    getTeamMemberRoute(teamId: string, userId: string): string;
    getChannelsRoute(): string;
    getChannelRoute(channelId: string): string;
    getChannelMembersRoute(channelId: string): string;
    getChannelMemberRoute(channelId: string, userId: string): string;
    getChannelSchemeRoute(channelId: string): string;
    getChannelBookmarksRoute(channelId: string): string;
    getChannelBookmarkRoute(channelId: string, bookmarkId: string): string;
    getChannelCategoriesRoute(userId: string, teamId: string): string;
    getPostsRoute(): string;
    getPostRoute(postId: string): string;
    getReactionsRoute(): string;
    getCommandsRoute(): string;
    getFilesRoute(): string;
    getFileRoute(fileId: string): string;
    getPreferencesRoute(userId: string): string;
    getIncomingHooksRoute(): string;
    getIncomingHookRoute(hookId: string): string;
    getOutgoingHooksRoute(): string;
    getOutgoingHookRoute(hookId: string): string;
    getOAuthRoute(): string;
    getOAuthAppsRoute(): string;
    getOAuthAppRoute(appId: string): string;
    getOutgoingOAuthConnectionsRoute(): string;
    getOutgoingOAuthConnectionRoute(connectionId: string): string;
    getEmojisRoute(): string;
    getEmojiRoute(emojiId: string): string;
    getBrandRoute(): string;
    getBrandImageUrl(timestamp: string): string;
    getDataRetentionRoute(): string;
    getJobsRoute(): string;
    getPluginsRoute(): string;
    getPluginRoute(pluginId: string): string;
    getPluginsMarketplaceRoute(): string;
    getRolesRoute(): string;
    getSchemesRoute(): string;
    getBotsRoute(): string;
    getBotRoute(botUserId: string): string;
    getGroupsRoute(): string;
    getGroupRoute(groupID: string): string;
    getNoticesRoute(): string;
    getCloudRoute(): string;
    getHostedCustomerRoute(): string;
    getUsageRoute(): string;
    getPermissionsRoute(): string;
    getUserThreadsRoute(userID: string, teamID: string): string;
    getUserThreadRoute(userId: string, teamId: string, threadId: string): string;
    getSystemRoute(): string;
    getDraftsRoute(): string;
    getReportsRoute(): string;
    getLimitsRoute(): string;
    getServerLimitsRoute(): string;
    getClientMetricsRoute(): string;
    getCSRFFromCookie(): string;
    getOptions(options: Options): {
        headers: {
            [x: string]: string;
        };
        method?: string | undefined;
        url?: string | undefined;
        credentials?: "omit" | "include" | "same-origin" | undefined;
        body?: any;
        signal?: AbortSignal | null | undefined;
        ignoreStatus?: boolean | undefined;
    };
    createUser: (user: UserProfile, token: string, inviteId: string, redirect?: string) => Promise<UserProfile>;
    patchMe: (userPatch: Partial<UserProfile>) => Promise<UserProfile>;
    patchUser: (userPatch: Partial<UserProfile> & {
        id: string;
    }) => Promise<UserProfile>;
    updateUser: (user: UserProfile) => Promise<UserProfile>;
    promoteGuestToUser: (userId: string) => Promise<StatusOK>;
    demoteUserToGuest: (userId: string) => Promise<StatusOK>;
    updateUserRoles: (userId: string, roles: string) => Promise<StatusOK>;
    updateUserMfa: (userId: string, activate: boolean, code: string) => Promise<StatusOK>;
    updateUserPassword: (userId: string, currentPassword: string, newPassword: string) => Promise<StatusOK>;
    resetUserPassword: (token: string, newPassword: string) => Promise<StatusOK>;
    getKnownUsers: () => Promise<string[]>;
    sendPasswordResetEmail: (email: string) => Promise<StatusOK>;
    updateUserActive: (userId: string, active: boolean) => Promise<StatusOK>;
    uploadProfileImage: (userId: string, imageData: File) => Promise<StatusOK>;
    setDefaultProfileImage: (userId: string) => Promise<StatusOK>;
    verifyUserEmail: (token: string) => Promise<StatusOK>;
    updateMyTermsOfServiceStatus: (termsOfServiceId: string, accepted: boolean) => Promise<StatusOK>;
    getTermsOfService: () => Promise<TermsOfService>;
    createTermsOfService: (text: string) => Promise<TermsOfService>;
    sendVerificationEmail: (email: string) => Promise<StatusOK>;
    login: (loginId: string, password: string, token?: string, ldapOnly?: boolean) => Promise<UserProfile>;
    loginWithDesktopToken: (token: string) => Promise<UserProfile>;
    loginById: (id: string, password: string, token?: string) => Promise<UserProfile>;
    logout: () => Promise<Response>;
    getProfiles: (page?: number, perPage?: number, options?: Record<string, any>) => Promise<UserProfile[]>;
    getProfilesByIds: (userIds: string[], options?: {}) => Promise<UserProfile[]>;
    getProfilesByUsernames: (usernames: string[]) => Promise<UserProfile[]>;
    getProfilesInTeam: (teamId: string, page?: number, perPage?: number, sort?: string, options?: {}) => Promise<UserProfile[]>;
    getProfilesNotInTeam: (teamId: string, groupConstrained: boolean, page?: number, perPage?: number) => Promise<UserProfile[]>;
    getProfilesWithoutTeam: (page?: number, perPage?: number, options?: {}) => Promise<UserProfile[]>;
    getProfilesInChannel: (channelId: string, page?: number, perPage?: number, sort?: string, options?: {
        active?: boolean;
    }) => Promise<UserProfile[]>;
    getProfilesInGroupChannels: (channelsIds: string[]) => Promise<Record<string, UserProfile[]>>;
    getProfilesNotInChannel: (teamId: string, channelId: string, groupConstrained: boolean, page?: number, perPage?: number) => Promise<UserProfile[]>;
    getProfilesInGroup: (groupId: string, page?: number, perPage?: number, sort?: string) => Promise<UserProfile[]>;
    getProfilesNotInGroup: (groupId: string, page?: number, perPage?: number) => Promise<UserProfile[]>;
    getMe: () => Promise<UserProfile>;
    getUser: (userId: string) => Promise<UserProfile>;
    getUserByUsername: (username: string) => Promise<UserProfile>;
    getUserByEmail: (email: string) => Promise<UserProfile>;
    getProfilePictureUrl: (userId: string, lastPictureUpdate: number) => string;
    getDefaultProfilePictureUrl: (userId: string) => string;
    autocompleteUsers: (name: string, teamId: string, channelId: string, options?: {
        limit: number;
    }) => Promise<UserAutocomplete>;
    getSessions: (userId: string) => Promise<Session[]>;
    revokeSession: (userId: string, sessionId: string) => Promise<StatusOK>;
    revokeAllSessionsForUser: (userId: string) => Promise<StatusOK>;
    revokeSessionsForAllUsers: () => Promise<StatusOK>;
    getUserAudits: (userId: string, page?: number, perPage?: number) => Promise<Audit[]>;
    getUsersForReporting: (filter: UserReportOptions) => Promise<UserReport[]>;
    getUserCountForReporting: (filter: UserReportFilter) => Promise<number>;
    startUsersBatchExport: (dateRange: string) => Promise<StatusOK>;
    /**
     * @deprecated
     */
    checkUserMfa: (loginId: string) => Promise<{
        mfa_required: boolean;
    }>;
    generateMfaSecret: (userId: string) => Promise<MfaSecret>;
    searchUsers: (term: string, options: any) => Promise<UserProfile[]>;
    getStatusesByIds: (userIds: string[]) => Promise<UserStatus[]>;
    getStatus: (userId: string) => Promise<UserStatus>;
    updateStatus: (status: UserStatus) => Promise<UserStatus>;
    updateCustomStatus: (customStatus: UserCustomStatus) => Promise<unknown>;
    unsetCustomStatus: () => Promise<unknown>;
    removeRecentCustomStatus: (customStatus: UserCustomStatus) => Promise<unknown>;
    moveThread: (postId: string, channelId: string) => Promise<StatusOK>;
    switchEmailToOAuth: (service: string, email: string, password: string, mfaCode?: string) => Promise<AuthChangeResponse>;
    switchOAuthToEmail: (currentService: string, email: string, password: string) => Promise<AuthChangeResponse>;
    switchEmailToLdap: (email: string, emailPassword: string, ldapId: string, ldapPassword: string, mfaCode?: string) => Promise<AuthChangeResponse>;
    switchLdapToEmail: (ldapPassword: string, email: string, emailPassword: string, mfaCode?: string) => Promise<AuthChangeResponse>;
    getAuthorizedOAuthApps: (userId: string) => Promise<OAuthApp[]>;
    authorizeOAuthApp: (responseType: string, clientId: string, redirectUri: string, state: string, scope: string) => Promise<void>;
    deauthorizeOAuthApp: (clientId: string) => Promise<StatusOK>;
    createUserAccessToken: (userId: string, description: string) => Promise<UserAccessToken>;
    getUserAccessToken: (tokenId: string) => Promise<UserAccessToken>;
    getUserAccessTokensForUser: (userId: string, page?: number, perPage?: number) => Promise<UserAccessToken[]>;
    getUserAccessTokens: (page?: number, perPage?: number) => Promise<UserAccessToken[]>;
    revokeUserAccessToken: (tokenId: string) => Promise<StatusOK>;
    disableUserAccessToken: (tokenId: string) => Promise<StatusOK>;
    enableUserAccessToken: (tokenId: string) => Promise<StatusOK>;
    getServerLimits: () => Promise<ClientResponse<ServerLimits>>;
    createTeam: (team: Team) => Promise<Team>;
    deleteTeam: (teamId: string) => Promise<StatusOK>;
    unarchiveTeam: (teamId: string) => Promise<Team>;
    updateTeam: (team: Team) => Promise<Team>;
    patchTeam: (team: Partial<Team> & {
        id: string;
    }) => Promise<Team>;
    regenerateTeamInviteId: (teamId: string) => Promise<Team>;
    updateTeamScheme: (teamId: string, schemeId: string) => Promise<StatusOK>;
    checkIfTeamExists: (teamName: string) => Promise<{
        exists: boolean;
    }>;
    getTeams: (page?: number, perPage?: number, includeTotalCount?: boolean, excludePolicyConstrained?: boolean) => Promise<Team[] | TeamsWithCount>;
    searchTeams(term: string, opts: PagedTeamSearchOpts): Promise<Team[]>;
    searchTeams(term: string, opts: NotPagedTeamSearchOpts): Promise<TeamsWithCount>;
    getTeam: (teamId: string) => Promise<Team>;
    getTeamByName: (teamName: string) => Promise<Team>;
    getMyTeams: () => Promise<Team[]>;
    getTeamsForUser: (userId: string) => Promise<Team[]>;
    getMyTeamMembers: () => Promise<TeamMembership[]>;
    getMyTeamUnreads: (includeCollapsedThreads?: boolean) => Promise<TeamUnread[]>;
    getTeamMembers: (teamId: string, page?: number, perPage?: number, options?: GetTeamMembersOpts) => Promise<TeamMembership[]>;
    getTeamMembersForUser: (userId: string) => Promise<TeamMembership[]>;
    getTeamMember: (teamId: string, userId: string) => Promise<TeamMembership>;
    getTeamMembersByIds: (teamId: string, userIds: string[]) => Promise<TeamMembership[]>;
    addToTeam: (teamId: string, userId: string) => Promise<TeamMembership>;
    addToTeamFromInvite: (token?: string, inviteId?: string) => Promise<TeamMembership>;
    addUsersToTeam: (teamId: string, userIds: string[]) => Promise<TeamMembership[]>;
    addUsersToTeamGracefully: (teamId: string, userIds: string[]) => Promise<TeamMemberWithError[]>;
    joinTeam: (inviteId: string) => Promise<TeamMembership>;
    removeFromTeam: (teamId: string, userId: string) => Promise<StatusOK>;
    getTeamStats: (teamId: string) => Promise<TeamStats>;
    getTotalUsersStats: () => Promise<UsersStats>;
    getFilteredUsersStats: (options: GetFilteredUsersStatsOpts) => Promise<UsersStats>;
    invalidateAllEmailInvites: () => Promise<StatusOK>;
    getTeamInviteInfo: (inviteId: string) => Promise<{
        display_name: string;
        description: string;
        name: string;
        id: string;
    }>;
    updateTeamMemberRoles: (teamId: string, userId: string, roles: string[]) => Promise<StatusOK>;
    sendEmailInvitesToTeam: (teamId: string, emails: string[]) => Promise<StatusOK>;
    sendEmailGuestInvitesToChannels: (teamId: string, channelIds: string[], emails: string[], message: string) => Promise<StatusOK>;
    sendEmailInvitesToTeamGracefully: (teamId: string, emails: string[]) => Promise<TeamInviteWithError[]>;
    sendEmailInvitesToTeamAndChannelsGracefully: (teamId: string, channelIds: string[], emails: string[], message: string) => Promise<TeamInviteWithError[]>;
    sendEmailGuestInvitesToChannelsGracefully: (teamId: string, channelIds: string[], emails: string[], message: string) => Promise<TeamInviteWithError[]>;
    getTeamIconUrl: (teamId: string, lastTeamIconUpdate: number) => string;
    setTeamIcon: (teamId: string, imageData: File) => Promise<StatusOK>;
    removeTeamIcon: (teamId: string) => Promise<StatusOK>;
    updateTeamMemberSchemeRoles: (teamId: string, userId: string, isSchemeUser: boolean, isSchemeAdmin: boolean) => Promise<StatusOK>;
    getAllChannels(page: number | undefined, perPage: number | undefined, notAssociatedToGroup: string | undefined, excludeDefaultChannels: boolean | undefined, includeTotalCount: false | undefined, includeDeleted: boolean | undefined, excludePolicyConstrained: boolean | undefined): Promise<ChannelWithTeamData[]>;
    getAllChannels(page: number | undefined, perPage: number | undefined, notAssociatedToGroup: string | undefined, excludeDefaultChannels: boolean | undefined, includeTotalCount: true, includeDeleted: boolean | undefined, excludePolicyConstrained: boolean | undefined): Promise<ChannelsWithTotalCount>;
    createChannel: (channel: Channel) => Promise<ServerChannel>;
    createDirectChannel: (userIds: string[]) => Promise<ServerChannel>;
    createGroupChannel: (userIds: string[]) => Promise<ServerChannel>;
    deleteChannel: (channelId: string) => Promise<StatusOK>;
    unarchiveChannel: (channelId: string) => Promise<ServerChannel>;
    updateChannel: (channel: Channel) => Promise<ServerChannel>;
    updateChannelPrivacy: (channelId: string, privacy: any) => Promise<ServerChannel>;
    patchChannel: (channelId: string, channelPatch: Partial<Channel>) => Promise<ServerChannel>;
    updateChannelNotifyProps: (props: any) => Promise<StatusOK>;
    updateChannelScheme: (channelId: string, schemeId: string) => Promise<StatusOK>;
    getChannel: (channelId: string) => Promise<ServerChannel>;
    getChannelByName: (teamId: string, channelName: string, includeDeleted?: boolean) => Promise<ServerChannel>;
    getChannelByNameAndTeamName: (teamName: string, channelName: string, includeDeleted?: boolean) => Promise<ServerChannel>;
    getChannels: (teamId: string, page?: number, perPage?: number) => Promise<ServerChannel[]>;
    getAllTeamsChannels: () => Promise<ServerChannel[]>;
    getArchivedChannels: (teamId: string, page?: number, perPage?: number) => Promise<ServerChannel[]>;
    getMyChannels: (teamId: string, includeDeleted?: boolean) => Promise<ServerChannel[]>;
    getAllChannelsMembers: (userId: string, page?: number, perPage?: number) => Promise<ChannelMembership[]>;
    getMyChannelMember: (channelId: string) => Promise<ChannelMembership>;
    getMyChannelMembers: (teamId: string) => Promise<ChannelMembership[]>;
    getChannelMembers: (channelId: string, page?: number, perPage?: number) => Promise<ChannelMembership[]>;
    getChannelTimezones: (channelId: string) => Promise<string[]>;
    getChannelMember: (channelId: string, userId: string) => Promise<ChannelMembership>;
    getChannelMembersByIds: (channelId: string, userIds: string[]) => Promise<ChannelMembership[]>;
    addToChannels: (userIds: string[], channelId: string, postRootId?: string) => Promise<ChannelMembership[]>;
    addToChannel: (userId: string, channelId: string, postRootId?: string) => Promise<ChannelMembership>;
    removeFromChannel: (userId: string, channelId: string) => Promise<StatusOK>;
    updateChannelMemberRoles: (channelId: string, userId: string, roles: string) => Promise<StatusOK>;
    getChannelStats: (channelId: string, includeFileCount?: boolean) => Promise<ChannelStats>;
    getChannelsMemberCount: (channelIds: string[]) => Promise<Record<string, number>>;
    getChannelModerations: (channelId: string) => Promise<ChannelModeration[]>;
    patchChannelModerations: (channelId: string, channelModerationsPatch: ChannelModerationPatch[]) => Promise<ChannelModeration[]>;
    getChannelMemberCountsByGroup: (channelId: string, includeTimezones: boolean) => Promise<ChannelMemberCountsByGroup>;
    viewMyChannel: (channelId: string) => Promise<ChannelViewResponse>;
    readMultipleChannels: (channelIds: string[]) => Promise<ChannelViewResponse>;
    autocompleteChannels: (teamId: string, name: string) => Promise<Channel[]>;
    autocompleteChannelsForSearch: (teamId: string, name: string) => Promise<Channel[]>;
    searchChannels: (teamId: string, term: string) => Promise<Channel[]>;
    searchArchivedChannels: (teamId: string, term: string) => Promise<Channel[]>;
    searchAllChannels(term: string, opts: {
        page: number;
        per_page: number;
    } & ChannelSearchOpts): Promise<ChannelsWithTotalCount>;
    searchAllChannels(term: string, opts: Omit<ChannelSearchOpts, 'page' | 'per_page'> | undefined): Promise<ChannelWithTeamData[]>;
    searchGroupChannels: (term: string) => Promise<Channel[]>;
    updateChannelMemberSchemeRoles: (channelId: string, userId: string, isSchemeUser: boolean, isSchemeAdmin: boolean) => Promise<StatusOK>;
    getChannelBookmarks: (channelId: string, bookmarksSince?: number) => Promise<ChannelBookmark[]>;
    createChannelBookmark: (channelId: string, channelBookmark: ChannelBookmarkCreate, connectionId: string) => Promise<ChannelBookmark>;
    deleteChannelBookmark: (channelId: string, channelBookmarkId: string, connectionId: string) => Promise<ChannelBookmark>;
    updateChannelBookmark: (channelId: string, channelBookmarkId: string, patch: ChannelBookmarkPatch, connectionId: string) => Promise<{
        updated: ChannelBookmark;
        deleted: ChannelBookmark;
    }>;
    updateChannelBookmarkSortOrder: (channelId: string, channelBookmarkId: string, newOrder: number, connectionId: string) => Promise<ChannelBookmark[]>;
    getChannelCategories: (userId: string, teamId: string) => Promise<OrderedChannelCategories>;
    createChannelCategory: (userId: string, teamId: string, category: Partial<ChannelCategory>) => Promise<ChannelCategory>;
    updateChannelCategories: (userId: string, teamId: string, categories: ChannelCategory[]) => Promise<ChannelCategory[]>;
    getChannelCategoryOrder: (userId: string, teamId: string) => Promise<string[]>;
    updateChannelCategoryOrder: (userId: string, teamId: string, categoryOrder: string[]) => Promise<string[]>;
    getChannelCategory: (userId: string, teamId: string, categoryId: string) => Promise<ChannelCategory>;
    updateChannelCategory: (userId: string, teamId: string, category: ChannelCategory) => Promise<ChannelCategory>;
    deleteChannelCategory: (userId: string, teamId: string, categoryId: string) => Promise<ChannelCategory>;
    createPost: (post: Post) => Promise<Post>;
    updatePost: (post: Post) => Promise<Post>;
    getPost: (postId: string) => Promise<Post>;
    patchPost: (postPatch: Partial<Post> & {
        id: string;
    }) => Promise<Post>;
    deletePost: (postId: string) => Promise<StatusOK>;
    getPostThread: (postId: string, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PaginatedPostList>;
    getPaginatedPostThread: (postId: string, options: FetchPaginatedThreadOptions) => Promise<PaginatedPostList>;
    getPosts: (channelId: string, page?: number, perPage?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsUnread: (channelId: string, userId: string, limitAfter?: number, limitBefore?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsSince: (channelId: string, since: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsBefore: (channelId: string, postId: string, page?: number, perPage?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsAfter: (channelId: string, postId: string, page?: number, perPage?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getUserThreads: (userId: string | undefined, teamId: Team['id'], { before, after, perPage, extended, deleted, unread, since, totalsOnly, threadsOnly, }: {
        before?: string | undefined;
        after?: string | undefined;
        perPage?: number | undefined;
        extended?: boolean | undefined;
        deleted?: boolean | undefined;
        unread?: boolean | undefined;
        since?: number | undefined;
        totalsOnly?: boolean | undefined;
        threadsOnly?: boolean | undefined;
    }) => Promise<UserThreadList>;
    getUserThread: (userId: string, teamId: string, threadId: string, extended?: boolean) => Promise<UserThreadWithPost>;
    updateThreadsReadForUser: (userId: string, teamId: string) => Promise<StatusOK>;
    updateThreadReadForUser: (userId: string, teamId: string, threadId: string, timestamp: number) => Promise<UserThread>;
    markThreadAsUnreadForUser: (userId: string, teamId: string, threadId: string, postId: string) => Promise<UserThread>;
    updateThreadFollowForUser: (userId: string, teamId: string, threadId: string, state: boolean) => Promise<StatusOK>;
    getFileInfosForPost: (postId: string) => Promise<FileInfo[]>;
    getFlaggedPosts: (userId: string, channelId?: string, teamId?: string, page?: number, perPage?: number) => Promise<PostList>;
    getPinnedPosts: (channelId: string) => Promise<PostList>;
    markPostAsUnread: (userId: string, postId: string) => Promise<ChannelUnread>;
    addPostReminder: (userId: string, postId: string, timestamp: number) => Promise<StatusOK>;
    pinPost: (postId: string) => Promise<StatusOK>;
    unpinPost: (postId: string) => Promise<StatusOK>;
    getPostInfo: (postId: string) => Promise<PostInfo>;
    getPostsByIds: (postIds: string[]) => Promise<Post[]>;
    getPostEditHistory: (postId: string) => Promise<Post[]>;
    addReaction: (userId: string, postId: string, emojiName: string) => Promise<Reaction>;
    removeReaction: (userId: string, postId: string, emojiName: string) => Promise<StatusOK>;
    getReactionsForPost: (postId: string) => Promise<Reaction[]>;
    searchPostsWithParams: (teamId: string, params: any) => Promise<PostSearchResults>;
    searchPosts: (teamId: string, terms: string, isOrSearch: boolean) => Promise<PostSearchResults>;
    searchFilesWithParams: (teamId: string, params: any) => Promise<FileSearchResults>;
    searchFiles: (teamId: string, terms: string, isOrSearch: boolean) => Promise<FileSearchResults>;
    doPostAction: (postId: string, actionId: string, selectedOption?: string) => Promise<PostActionResponse>;
    doPostActionWithCookie: (postId: string, actionId: string, actionCookie: string, selectedOption?: string) => Promise<PostActionResponse>;
    getFileUrl(fileId: string, timestamp: number): string;
    getFileThumbnailUrl(fileId: string, timestamp: number): string;
    getFilePreviewUrl(fileId: string, timestamp: number): string;
    uploadFile: (fileFormData: any, isBookmark?: boolean) => Promise<FileUploadResponse>;
    getFilePublicLink: (fileId: string) => Promise<{
        link: string;
    }>;
    acknowledgePost: (postId: string, userId: string) => Promise<PostAcknowledgement>;
    unacknowledgePost: (postId: string, userId: string) => Promise<null>;
    savePreferences: (userId: string, preferences: PreferenceType[]) => Promise<StatusOK>;
    getMyPreferences: () => Promise<PreferenceType>;
    getUserPreferences: (userId: string) => Promise<PreferenceType[]>;
    deletePreferences: (userId: string, preferences: PreferenceType[]) => Promise<StatusOK>;
    ping: (getServerStatus: boolean, deviceId?: string) => Promise<{
        status: string;
        ActiveSearchBackend: string;
        database_status: string;
        filestore_status: string;
    }>;
    upgradeToEnterprise: () => Promise<StatusOK>;
    upgradeToEnterpriseStatus: () => Promise<{
        percentage: number;
        error: string | null;
    }>;
    restartServer: () => Promise<StatusOK>;
    logClientError: (message: string, level?: LogLevel) => Promise<{
        message: string;
    }>;
    getClientConfigOld: () => Promise<ClientConfig>;
    getClientLicenseOld: () => Promise<ClientLicense>;
    setFirstAdminVisitMarketplaceStatus: () => Promise<StatusOK>;
    getFirstAdminVisitMarketplaceStatus: () => Promise<SystemSetting>;
    getFirstAdminSetupComplete: () => Promise<SystemSetting>;
    getTranslations: (url: string) => Promise<Record<string, string>>;
    getWebSocketUrl: () => string;
    createIncomingWebhook: (hook: IncomingWebhook) => Promise<IncomingWebhook>;
    getIncomingWebhook: (hookId: string) => Promise<IncomingWebhook>;
    getIncomingWebhooks: (teamId?: string, page?: number, perPage?: number, includeTotalCount?: boolean) => Promise<IncomingWebhook[] | IncomingWebhooksWithCount>;
    removeIncomingWebhook: (hookId: string) => Promise<StatusOK>;
    updateIncomingWebhook: (hook: IncomingWebhook) => Promise<IncomingWebhook>;
    createOutgoingWebhook: (hook: OutgoingWebhook) => Promise<OutgoingWebhook>;
    getOutgoingWebhook: (hookId: string) => Promise<OutgoingWebhook>;
    getOutgoingWebhooks: (channelId?: string, teamId?: string, page?: number, perPage?: number) => Promise<OutgoingWebhook[]>;
    removeOutgoingWebhook: (hookId: string) => Promise<StatusOK>;
    updateOutgoingWebhook: (hook: OutgoingWebhook) => Promise<OutgoingWebhook>;
    regenOutgoingHookToken: (id: string) => Promise<OutgoingWebhook>;
    getCommandsList: (teamId: string) => Promise<Command[]>;
    getCommandAutocompleteSuggestionsList: (userInput: string, teamId: string, commandArgs: CommandArgs) => Promise<AutocompleteSuggestion[]>;
    getAutocompleteCommandsList: (teamId: string, page?: number, perPage?: number) => Promise<Command[]>;
    getCustomTeamCommands: (teamId: string) => Promise<Command[]>;
    executeCommand: (command: string, commandArgs: CommandArgs) => Promise<CommandResponse>;
    addCommand: (command: Command) => Promise<Command>;
    editCommand: (command: Command) => Promise<Command>;
    regenCommandToken: (id: string) => Promise<{
        token: string;
    }>;
    deleteCommand: (id: string) => Promise<StatusOK>;
    createOAuthApp: (app: OAuthApp) => Promise<OAuthApp>;
    editOAuthApp: (app: OAuthApp) => Promise<OAuthApp>;
    getOAuthApps: (page?: number, perPage?: number) => Promise<OAuthApp[]>;
    getAppsOAuthAppIDs: () => Promise<string[]>;
    getAppsBotIDs: () => Promise<string[]>;
    getOAuthApp: (appId: string) => Promise<OAuthApp>;
    getOutgoingOAuthConnections: (teamId: string, page?: number, perPage?: number) => Promise<OutgoingOAuthConnection[]>;
    getOutgoingOAuthConnectionsForAudience: (teamId: string, audience: string, page?: number, perPage?: number) => Promise<OutgoingOAuthConnection[]>;
    getOutgoingOAuthConnection: (teamId: string, connectionId: string) => Promise<OutgoingOAuthConnection>;
    createOutgoingOAuthConnection: (teamId: string, connection: OutgoingOAuthConnection) => Promise<OutgoingOAuthConnection>;
    editOutgoingOAuthConnection: (teamId: string, connection: OutgoingOAuthConnection) => Promise<OutgoingOAuthConnection>;
    validateOutgoingOAuthConnection: (teamId: string, connection: OutgoingOAuthConnection) => Promise<OutgoingOAuthConnection>;
    getOAuthAppInfo: (appId: string) => Promise<OAuthApp>;
    deleteOAuthApp: (appId: string) => Promise<StatusOK>;
    regenOAuthAppSecret: (appId: string) => Promise<OAuthApp>;
    deleteOutgoingOAuthConnection: (connectionId: string) => Promise<StatusOK>;
    submitInteractiveDialog: (data: DialogSubmission) => Promise<SubmitDialogResponse>;
    createCustomEmoji: (emoji: CustomEmoji, imageData: File) => Promise<CustomEmoji>;
    getCustomEmoji: (id: string) => Promise<CustomEmoji>;
    getCustomEmojiByName: (name: string) => Promise<CustomEmoji>;
    getCustomEmojisByNames: (names: string[]) => Promise<CustomEmoji[]>;
    getCustomEmojis: (page?: number, perPage?: number, sort?: string) => Promise<CustomEmoji[]>;
    deleteCustomEmoji: (emojiId: string) => Promise<StatusOK>;
    getSystemEmojiImageUrl: (filename: string) => string;
    getCustomEmojiImageUrl: (id: string) => string;
    searchCustomEmoji: (term: string, options?: {}) => Promise<CustomEmoji[]>;
    autocompleteCustomEmoji: (name: string) => Promise<CustomEmoji[]>;
    getDataRetentionPolicy: () => Promise<DataRetentionPolicy>;
    getDataRetentionCustomPolicies: (page?: number, perPage?: number) => Promise<GetDataRetentionCustomPoliciesRequest>;
    getDataRetentionCustomPolicy: (id: string) => Promise<DataRetentionCustomPolicies>;
    deleteDataRetentionCustomPolicy: (id: string) => Promise<DataRetentionCustomPolicies>;
    searchDataRetentionCustomPolicyChannels: (policyId: string, term: string, opts: ChannelSearchOpts) => Promise<DataRetentionCustomPolicies>;
    searchDataRetentionCustomPolicyTeams: (policyId: string, term: string, opts: TeamSearchOpts) => Promise<DataRetentionCustomPolicies>;
    getDataRetentionCustomPolicyTeams: (id: string, page?: number, perPage?: number) => Promise<Team[]>;
    getDataRetentionCustomPolicyChannels: (id: string, page?: number, perPage?: number) => Promise<{
        channels: Channel[];
        total_count: number;
    }>;
    createDataRetentionPolicy: (policy: CreateDataRetentionCustomPolicy) => Promise<DataRetentionCustomPolicies>;
    updateDataRetentionPolicy: (id: string, policy: PatchDataRetentionCustomPolicy) => Promise<DataRetentionCustomPolicies>;
    addDataRetentionPolicyTeams: (id: string, teams: string[]) => Promise<DataRetentionCustomPolicies>;
    removeDataRetentionPolicyTeams: (id: string, teams: string[]) => Promise<DataRetentionCustomPolicies>;
    addDataRetentionPolicyChannels: (id: string, channels: string[]) => Promise<DataRetentionCustomPolicies>;
    removeDataRetentionPolicyChannels: (id: string, channels: string[]) => Promise<DataRetentionCustomPolicies>;
    getJob: (id: string) => Promise<Job>;
    getJobs: (page?: number, perPage?: number) => Promise<Job[]>;
    getJobsByType: (type: string, page?: number, perPage?: number) => Promise<Job[]>;
    createJob: (job: JobTypeBase) => Promise<Job>;
    cancelJob: (id: string) => Promise<StatusOK>;
    getLogs: (logFilter: LogFilterQuery) => Promise<string[]>;
    getPlainLogs: (page?: number, perPage?: number) => Promise<string[]>;
    getAudits: (page?: number, perPage?: number) => Promise<Audit[]>;
    getConfig: () => Promise<AdminConfig>;
    updateConfig: (config: AdminConfig) => Promise<AdminConfig>;
    patchConfig: (patch: DeepPartial<AdminConfig>) => Promise<AdminConfig>;
    reloadConfig: () => Promise<StatusOK>;
    getEnvironmentConfig: () => Promise<EnvironmentConfig>;
    testEmail: (config?: AdminConfig) => Promise<StatusOK>;
    testSiteURL: (siteURL: string) => Promise<StatusOK>;
    testS3Connection: (config?: AdminConfig) => Promise<StatusOK>;
    invalidateCaches: () => Promise<StatusOK>;
    recycleDatabase: () => Promise<StatusOK>;
    createComplianceReport: (job: Partial<Compliance>) => Promise<Compliance>;
    getComplianceReport: (reportId: string) => Promise<Compliance>;
    getComplianceReports: (page?: number, perPage?: number) => Promise<Compliance[]>;
    uploadBrandImage: (imageData: File) => Promise<StatusOK>;
    deleteBrandImage: () => Promise<StatusOK>;
    getClusterStatus: () => Promise<ClusterInfo[]>;
    testLdap: () => Promise<StatusOK>;
    syncLdap: () => Promise<StatusOK>;
    getLdapGroups: (page?: number, perPage?: number, opts?: {}) => Promise<{
        count: number;
        groups: MixedUnlinkedGroup[];
    }>;
    linkLdapGroup: (key: string) => Promise<Group>;
    unlinkLdapGroup: (key: string) => Promise<StatusOK>;
    getSamlCertificateStatus: () => Promise<SamlCertificateStatus>;
    uploadPublicSamlCertificate: (fileData: File) => Promise<StatusOK>;
    uploadPrivateSamlCertificate: (fileData: File) => Promise<StatusOK>;
    uploadPublicLdapCertificate: (fileData: File) => Promise<StatusOK>;
    uploadPrivateLdapCertificate: (fileData: File) => Promise<StatusOK>;
    uploadIdpSamlCertificate: (fileData: File) => Promise<StatusOK>;
    deletePublicSamlCertificate: () => Promise<StatusOK>;
    deletePrivateSamlCertificate: () => Promise<StatusOK>;
    deletePublicLdapCertificate: () => Promise<StatusOK>;
    deletePrivateLdapCertificate: () => Promise<StatusOK>;
    deleteIdpSamlCertificate: () => Promise<StatusOK>;
    testElasticsearch: (config?: AdminConfig) => Promise<StatusOK>;
    purgeElasticsearchIndexes: (indexes?: string[]) => Promise<StatusOK>;
    purgeBleveIndexes: () => Promise<StatusOK>;
    uploadLicense: (fileData: File) => Promise<License>;
    requestTrialLicense: (body: RequestLicenseBody) => Promise<ClientResponse<ClientLicense>>;
    removeLicense: () => Promise<StatusOK>;
    getPrevTrialLicense: () => Promise<ClientLicense>;
    getAnalytics: (name?: string, teamId?: string) => Promise<AnalyticsRow[]>;
    getRole: (roleId: string) => Promise<Role>;
    getRoleByName: (roleName: string) => Promise<Role>;
    getRolesByNames: (rolesNames: string[]) => Promise<Role[]>;
    patchRole: (roleId: string, rolePatch: Partial<Role>) => Promise<Role>;
    getSchemes: (scope?: string, page?: number, perPage?: number) => Promise<Scheme[]>;
    createScheme: (scheme: Scheme) => Promise<Scheme>;
    getScheme: (schemeId: string) => Promise<Scheme>;
    deleteScheme: (schemeId: string) => Promise<StatusOK>;
    patchScheme: (schemeId: string, schemePatch: Partial<Scheme>) => Promise<Scheme>;
    getSchemeTeams: (schemeId: string, page?: number, perPage?: number) => Promise<Team[]>;
    getSchemeChannels: (schemeId: string, page?: number, perPage?: number) => Promise<Channel[]>;
    uploadPlugin: (fileData: File, force?: boolean) => Promise<PluginManifest>;
    installPluginFromUrl: (pluginDownloadUrl: string, force?: boolean) => Promise<PluginManifest>;
    getPlugins: () => Promise<PluginsResponse>;
    getRemoteMarketplacePlugins: (filter: string) => Promise<MarketplacePlugin[]>;
    getMarketplacePlugins: (filter: string, localOnly?: boolean) => Promise<MarketplacePlugin[]>;
    installMarketplacePlugin: (id: string) => Promise<MarketplacePlugin>;
    getMarketplaceApps: (filter: string) => Promise<MarketplaceApp[]>;
    getPluginStatuses: () => Promise<PluginStatus[]>;
    removePlugin: (pluginId: string) => Promise<StatusOK>;
    getWebappPlugins: () => Promise<ClientPluginManifest[]>;
    enablePlugin: (pluginId: string) => Promise<StatusOK>;
    disablePlugin: (pluginId: string) => Promise<StatusOK>;
    linkGroupSyncable: (groupID: string, syncableID: string, syncableType: string, patch: Partial<SyncablePatch>) => Promise<GroupSyncable>;
    unlinkGroupSyncable: (groupID: string, syncableID: string, syncableType: string) => Promise<StatusOK>;
    getGroupSyncables: (groupID: string, syncableType: string) => Promise<GroupSyncable[]>;
    getGroup: (groupID: string, includeMemberCount?: boolean) => Promise<Group>;
    getGroupStats: (groupID: string) => Promise<GroupStats>;
    getGroups: (opts: GetGroupsForUserParams | GetGroupsParams) => Promise<Group[]>;
    getGroupsByUserId: (userID: string) => Promise<Group[]>;
    getGroupsNotAssociatedToTeam: (teamID: string, q?: string, page?: number, perPage?: number, source?: string) => Promise<Group[]>;
    getGroupsNotAssociatedToChannel: (channelID: string, q?: string, page?: number, perPage?: number, filterParentTeamPermitted?: boolean, source?: string) => Promise<Group[]>;
    createGroupWithUserIds: (group: GroupCreateWithUserIds) => Promise<Group>;
    addUsersToGroup: (groupId: string, userIds: string[]) => Promise<UserProfile[]>;
    removeUsersFromGroup: (groupId: string, userIds: string[]) => Promise<UserProfile[]>;
    searchGroups: (params: GroupSearchParams) => Promise<Group[]>;
    executeAppCall: (call: AppCallRequest, trackAsSubmit: boolean) => Promise<AppCallResponse>;
    getAppsBindings: (channelID: string, teamID: string) => Promise<AppBinding[]>;
    getGroupsAssociatedToTeam: (teamID: string, q?: string, page?: number, perPage?: number, filterAllowReference?: boolean) => Promise<{
        groups: Group[];
        total_group_count: number;
    }>;
    getGroupsAssociatedToChannel: (channelID: string, q?: string, page?: number, perPage?: number, filterAllowReference?: boolean) => Promise<{
        groups: Group[];
        total_group_count: number;
    }>;
    getAllGroupsAssociatedToTeam: (teamID: string, filterAllowReference?: boolean, includeMemberCount?: boolean) => Promise<GroupsWithCount>;
    getAllGroupsAssociatedToChannelsInTeam: (teamID: string, filterAllowReference?: boolean) => Promise<{
        groups: RelationOneToOne<Channel, Group>;
    }>;
    getAllGroupsAssociatedToChannel: (channelID: string, filterAllowReference?: boolean, includeMemberCount?: boolean) => Promise<GroupsWithCount>;
    patchGroupSyncable: (groupID: string, syncableID: string, syncableType: string, patch: Partial<SyncablePatch>) => Promise<GroupSyncable>;
    patchGroup: (groupID: string, patch: GroupPatch | CustomGroupPatch) => Promise<Group>;
    archiveGroup: (groupId: string) => Promise<Group>;
    restoreGroup: (groupId: string) => Promise<Group>;
    createGroupTeamsAndChannels: (userID: string) => Promise<Group>;
    createBot: (bot: Partial<Bot>) => Promise<Bot>;
    patchBot: (botUserId: string, botPatch: Partial<BotPatch>) => Promise<Bot>;
    getBot: (botUserId: string) => Promise<Bot>;
    getBots: (page?: number, perPage?: number) => Promise<Bot[]>;
    getBotsIncludeDeleted: (page?: number, perPage?: number) => Promise<Bot[]>;
    getBotsOrphaned: (page?: number, perPage?: number) => Promise<Bot[]>;
    disableBot: (botUserId: string) => Promise<Bot>;
    enableBot: (botUserId: string) => Promise<Bot>;
    assignBot: (botUserId: string, newOwnerId: string) => Promise<Bot>;
    getCloudProducts: (includeLegacyProducts?: boolean) => Promise<Product[]>;
    getSelfHostedProducts: () => Promise<Product[]>;
    subscribeToNewsletter: (newletterRequestBody: NewsletterRequestBody) => Promise<StatusOK>;
    cwsAvailabilityCheck: () => Promise<ClientResponse<unknown>>;
    getCloudCustomer: () => Promise<CloudCustomer>;
    updateCloudCustomer: (customerPatch: CloudCustomerPatch) => Promise<CloudCustomer>;
    updateCloudCustomerAddress: (address: Address) => Promise<CloudCustomer>;
    notifyAdmin: (req: NotifyAdminRequest) => Promise<ClientResponse<StatusOK>>;
    validateBusinessEmail: (email?: string) => Promise<ClientResponse<ValidBusinessEmail>>;
    validateWorkspaceBusinessEmail: () => Promise<ClientResponse<ValidBusinessEmail>>;
    getSubscription: () => Promise<Subscription>;
    getInstallation: () => Promise<Installation>;
    getInvoices: () => Promise<Invoice[]>;
    getInvoicePdfUrl: (invoiceId: string) => string;
    getCloudLimits: () => Promise<Limits>;
    getPostsUsage: () => Promise<PostsUsageResponse>;
    getFilesUsage: () => Promise<FilesUsageResponse>;
    getTeamsUsage: () => Promise<TeamsUsageResponse>;
    teamMembersMinusGroupMembers: (teamID: string, groupIDs: string[], page: number, perPage: number) => Promise<UsersWithGroupsAndCount>;
    channelMembersMinusGroupMembers: (channelID: string, groupIDs: string[], page: number, perPage: number) => Promise<UsersWithGroupsAndCount>;
    getSamlMetadataFromIdp: (samlMetadataURL: string) => Promise<SamlMetadataResponse>;
    setSamlIdpCertificateFromMetadata: (certData: string) => Promise<StatusOK>;
    getInProductNotices: (teamId: string, client: string, clientVersion: string) => Promise<ProductNotices>;
    updateNoticesAsViewed: (noticeIds: string[]) => Promise<StatusOK>;
    getAncillaryPermissions: (subsectionPermissions: string[]) => Promise<string[]>;
    completeSetup: (completeOnboardingRequest: CompleteOnboardingRequest) => Promise<StatusOK>;
    getAppliedSchemaMigrations: () => Promise<SchemaMigration[]>;
    getCallsChannelState: (channelId: string) => Promise<{
        enabled: boolean;
        id: string;
    }>;
    protected doFetch: <ClientDataResponse>(url: string, options: Options) => Promise<ClientDataResponse>;
    private doFetchWithResponse;
    trackEvent(category: string, event: string, props?: any): void;
    pageVisited(category: string, name: string): void;
    upsertDraft: (draft: Draft, connectionId: string) => Promise<Draft>;
    getUserDrafts: (teamId: Team['id']) => Promise<Draft[]>;
    deleteDraft: (channelId: Channel['id'], rootId: string | undefined, connectionId: string) => Promise<null>;
    getIPFilters: () => Promise<AllowedIPRange[]>;
    getCurrentIP: () => Promise<FetchIPResponse>;
    applyIPFilters: (filters: AllowedIPRanges) => Promise<AllowedIPRange[]>;
    getGroupMessageMembersCommonTeams: (channelId: string) => Promise<ClientResponse<Team[]>>;
    convertGroupMessageToPrivateChannel: (channelId: string, teamId: string, displayName: string, name: string) => Promise<ClientResponse<Channel>>;
}
export declare function parseAndMergeNestedHeaders(originalHeaders: any): Map<any, any>;
export declare class ClientError extends Error implements ServerError {
    url?: string;
    server_error_id?: string;
    status_code?: number;
    constructor(baseUrl: string, data: ServerError, cause?: any);
}
